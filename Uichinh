local HttpService = game:GetService("HttpService")

loadstring(game:HttpGet('https://raw.githubusercontent.com/YouDanBezbul/Uimys/main/Uichinh'))()

-- Importing Configuration
local ImportedConfiguration = {}

pcall(function()
    if getfenv().isfile and getfenv().readfile and getfenv().isfile(string.format("%s.ttwizz", game.GameId)) and getfenv().readfile(string.format("%s.ttwizz", game.GameId)) then
        ImportedConfiguration = HttpService:JSONDecode(getfenv().readfile(string.format("%s.ttwizz", game.GameId)))
    end
end)

-- Initializing Configuration
local Configuration = {
    Khungxuong = ImportedConfiguration["Khung x∆∞∆°ng"] or false,
    Hop2d = ImportedConfiguration["H·ªôp 2D"] or false,
    Thanhmau = ImportedConfiguration["Thanh m√°u"] or false,
    Hienten = ImportedConfiguration["Hi·ªÉn th·ªã t√™n"] or false,
    TracersPosition = ImportedConfiguration["TracersPosition"] or "D∆∞·ªõi",
    High = ImportedConfiguration["Highlight"] or false,
    Box3 = ImportedConfiguration["Box3d"] or false,
    Dinhvido = ImportedConfiguration["Dinhvido"] or false,
    Aim = ImportedConfiguration["Aim"] or false,
    AimS = ImportedConfiguration["Aim"] or false
}

-- Fluent UI Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()


local tracersEnabled = false
local tracersObjects = {}
local tracersPosition = "D∆∞·ªõi"
local camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local UIVisible = true
local function ToggleUI()
    UIVisible = not UIVisible
    Window.Enabled = UIVisible
end

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.RightShift then
        ToggleUI()
    end
end)

-- UI Settings
local UISettings = {
    TabWidth = 160,
    Size = { 580, 460 },
    Theme = "Amethyst",
    MinimizeKey = "RightShift"
}

-- Initialize UI
local Window = Fluent:CreateWindow({
    Title = "YT:MiMonGaming",
    SubTitle = "Th·ª≠ nghi·ªám",
    TabWidth = UISettings.TabWidth,
    Size = UDim2.fromOffset(table.unpack(UISettings.Size)),
    Theme = UISettings.Theme,
    MinimizeKey = Enum.KeyCode.F1  -- ƒê·∫∑t ph√≠m ·∫©n/hi·ªán UI ·ªü ƒë√¢y
})

local Tabs = { 
    Main = Window:AddTab({ Title = "ƒê·ªãnh v·ªã", Icon = "settings" }),
    Team = Window:AddTab({ Title = "H·ªó tr·ª£ ng·∫Øm", Icon = "users" }),
    Info = Window:AddTab({ Title = "Th√¥ng b√°o ch·ªânh s·ª≠a", Icon = "users" })
}

Window:SelectTab(1)

-- Main Tab
Tabs.Main:AddParagraph({
    Title = "ƒê·ªãnh v·ªã c√≥ √°p d·ª•ng t·∫•t c·∫£ game",
    Content = "D√π t·∫•t c·∫£ game nh∆∞ng c√≥ game th√¨ kh√¥ng ƒë∆∞·ª£c!"
})

Tabs.Team:AddParagraph({
    Title = "ƒê√¢y l√† Aimbot h·ªó tr·ª£ m·ªçi game",
    Content = "Nh∆∞ng v√¨ th·ª≠ nghi·ªám nen c√≤n l·ªói. T√≠nh nƒÉng ch·ªânh v·ªã tr√≠ Fov ch∆∞a ·ªïn ƒë·ªãnh!"
})

Tabs.Info:AddParagraph({
    Title = "Th√¥ng tin c·∫≠p nh·∫≠t v√† s·ª≠a l·ªói",
    Content = "‚Ä¢Th√™m Aimbot Check v·∫≠t c·∫£n, v√¨ tr√™n di ƒë·ªông b·ªã h·∫°n ch·∫ø ch·ª©c nƒÉng n√†y!  ‚Ä¢Th√™m s·ªë th·ª© ƒê∆∞·ªùng k·∫ª v√† ch·ªânh l·∫°i l√† l·ªói"
})

local MainSection = Tabs.Main:AddSection("ESP")

-- Team Tab
local TeamSection = Tabs.Team:AddSection("Team Settings")


---------------------------------------------------------------------------- 
local KhungxuongToggle = MainSection:AddToggle("KXToggle", {
    Title = "Khung x∆∞∆°ng",
    Default = Configuration.KX
})

KhungxuongToggle:OnChanged(function(Value)
    Configuration.skeletonESPEnabled = Value
    if Value then
  
            -- Kh·ªüi t·∫°o v√† b·∫Øt ƒë·∫ßu SkeletonESP khi toggle ƒë∆∞·ª£c b·∫≠t
            SkeletonESP = loadstring([[
                local Players = game:GetService("Players")
                local RunService = game:GetService("RunService")

                local localPlayer = Players.LocalPlayer
                local camera = workspace.CurrentCamera

                local espObjects = {}
                local espEnabled = true

                local SkeletonESP = {}

                function SkeletonESP.createDrawings()
                    local esp = {
                        head = Drawing.new("Line"),
                        spine = Drawing.new("Line"),
                        leftUpperArm = Drawing.new("Line"),
                        leftLowerArm = Drawing.new("Line"),
                        rightUpperArm = Drawing.new("Line"),
                        rightLowerArm = Drawing.new("Line"),
                        leftUpperLeg = Drawing.new("Line"),
                        leftLowerLeg = Drawing.new("Line"),
                        rightUpperLeg = Drawing.new("Line"),
                        rightLowerLeg = Drawing.new("Line"),
                        leftFoot = Drawing.new("Line"),
                        rightFoot = Drawing.new("Line")
                    }
                    
                    for _, drawing in pairs(esp) do
                        drawing.Visible = false
                        drawing.Thickness = 2
                        drawing.Color = Color3.new(1, 0, 0)
                    end
                    
                    return esp
                end

                local function worldToScreen(position)
                    local screenPosition, onScreen = camera:WorldToViewportPoint(position)
                    return Vector2.new(screenPosition.X, screenPosition.Y), onScreen
                end

                function SkeletonESP.updateSkeleton(character, esp)
    local function updateLine(line, part1, part2)
        if part1 and part2 then
            local pos1, onScreen1 = worldToScreen(part1.Position)
            local pos2, onScreen2 = worldToScreen(part2.Position)
            if onScreen1 and onScreen2 then
                line.From = pos1
                line.To = pos2
                line.Visible = true
            else
                line.Visible = false
            end
        else
            line.Visible = false
        end
    end

    local head = character:FindFirstChild("Head")
    local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
    local lowerTorso = character:FindFirstChild("LowerTorso")
    local leftUpperArm = character:FindFirstChild("LeftUpperArm") or character:FindFirstChild("Left Arm")
    local leftLowerArm = character:FindFirstChild("LeftLowerArm")
    local leftHand = character:FindFirstChild("LeftHand")
    local rightUpperArm = character:FindFirstChild("RightUpperArm") or character:FindFirstChild("Right Arm")
    local rightLowerArm = character:FindFirstChild("RightLowerArm")
    local rightHand = character:FindFirstChild("RightHand")
    local leftUpperLeg = character:FindFirstChild("LeftUpperLeg") or character:FindFirstChild("Left Leg")
    local leftLowerLeg = character:FindFirstChild("LeftLowerLeg")
    local leftFoot = character:FindFirstChild("LeftFoot")
    local rightUpperLeg = character:FindFirstChild("RightUpperLeg") or character:FindFirstChild("Right Leg")
    local rightLowerLeg = character:FindFirstChild("RightLowerLeg")
    local rightFoot = character:FindFirstChild("RightFoot")

    updateLine(esp.head, head, torso)
    
    if lowerTorso then
        updateLine(esp.spine, torso, lowerTorso)
    else
        esp.spine.Visible = false
    end

    updateLine(esp.leftUpperArm, torso, leftUpperArm)
    if leftLowerArm then
        updateLine(esp.leftLowerArm, leftUpperArm, leftLowerArm)
    else
        updateLine(esp.leftLowerArm, leftUpperArm, leftHand or leftUpperArm)
    end

    updateLine(esp.rightUpperArm, torso, rightUpperArm)
    if rightLowerArm then
        updateLine(esp.rightLowerArm, rightUpperArm, rightLowerArm)
    else
        updateLine(esp.rightLowerArm, rightUpperArm, rightHand or rightUpperArm)
    end

    if lowerTorso then
        updateLine(esp.leftUpperLeg, lowerTorso, leftUpperLeg)
        updateLine(esp.rightUpperLeg, lowerTorso, rightUpperLeg)
    else
        updateLine(esp.leftUpperLeg, torso, leftUpperLeg)
        updateLine(esp.rightUpperLeg, torso, rightUpperLeg)
    end

    if leftLowerLeg then
        updateLine(esp.leftLowerLeg, leftUpperLeg, leftLowerLeg)
    else
        updateLine(esp.leftLowerLeg, leftUpperLeg, leftFoot or leftUpperLeg)
    end

    if rightLowerLeg then
        updateLine(esp.rightLowerLeg, rightUpperLeg, rightLowerLeg)
    else
        updateLine(esp.rightLowerLeg, rightUpperLeg, rightFoot or rightUpperLeg)
    end

    if leftFoot then
        updateLine(esp.leftFoot, leftLowerLeg or leftUpperLeg, leftFoot)
    else
        esp.leftFoot.Visible = false
    end

    if rightFoot then
        updateLine(esp.rightFoot, rightLowerLeg or rightUpperLeg, rightFoot)
    else
        esp.rightFoot.Visible = false
    end
end

                local function cleanupESP()
                    for _, esp in pairs(espObjects) do
                        for _, line in pairs(esp) do
                            line:Remove()
                        end
                    end
                    espObjects = {}
                end

                local function createESPForAllPlayers()
                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= localPlayer and not espObjects[player] then
                            espObjects[player] = SkeletonESP.createDrawings()
                        end
                    end
                end

                local function updateESP()
    if not espEnabled then
        for _, esp in pairs(espObjects) do
            for _, line in pairs(esp) do
                line.Visible = false
            end
        end
        return
    end

    local rainbowColor = Color3.fromHSV(tick() % 5 / 5, 1, 1)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local humanoid = character:FindFirstChild("Humanoid")
                local hrp = character.HumanoidRootPart
                
                local _, onScreen = camera:WorldToViewportPoint(hrp.Position)
                
                if onScreen and humanoid and humanoid.Health > 0 then
                    if not teamCheckEnabled or player.Team ~= localPlayer.Team then
                        local esp = espObjects[player]
                        if not esp then
                            esp = SkeletonESP.createDrawings()
                            espObjects[player] = esp
                        end
                        SkeletonESP.updateSkeleton(character, esp)
                        
                        if rainbowEnabled then
                            for _, line in pairs(esp) do
                                line.Color = rainbowColor
                            end
                        end
                    else
                        local esp = espObjects[player]
                        if esp then
                            for _, line in pairs(esp) do
                                line.Visible = false
                            end
                        end
                    end
                else
                    local esp = espObjects[player]
                    if esp then
                        for _, line in pairs(esp) do
                            line.Visible = false
                        end
                    end
                end
            else
                local esp = espObjects[player]
                if esp then
                    for _, line in pairs(esp) do
                        line.Visible = false
                    end
                end
            end
        end
    end
end

                local function onPlayerRemoving(player)
    local esp = espObjects[player]
    if esp then
        for _, line in pairs(esp) do
            line:Remove()
        end
        espObjects[player] = nil
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= localPlayer then
        espObjects[player] = SkeletonESP.createDrawings()
    end
end)

Players.PlayerRemoving:Connect(onPlayerRemoving)

RunService:BindToRenderStep("UpdateESP", Enum.RenderPriority.Camera.Value, updateESP)

createESPForAllPlayers()

return {
    ToggleESP = function(enabled)
        espEnabled = enabled
        if not enabled then
            for _, esp in pairs(espObjects) do
                for _, line in pairs(esp) do
                    line.Visible = false
                end
            end
        end
    end,
    SetBoxColor = function(color)
        for _, esp in pairs(espObjects) do
            for _, line in pairs(esp) do
                line.Color = color
            end
        end
    end,
    SetRainbowColor = function(enabled)
        rainbowEnabled = enabled
    end,
    SetTeamCheck = function(enabled)
        teamCheckEnabled = enabled
    end,
    Cleanup = function()
        RunService:UnbindFromRenderStep("UpdateESP")
        cleanupESP()
    end
}
            ]])()
        if SkeletonESP then
            SkeletonESP.ToggleESP(true)
        end
    else
        if SkeletonESP then
            SkeletonESP.ToggleESP(false)
            SkeletonESP.Cleanup()
            SkeletonESP = nil
        end
    end
end)

local rainbowEnabled = false
local teamCheckEnabled = false



local ColorPicker = MainSection:AddColorpicker("ESPColor", {
    Title = "M√†u ESP",
    Default = Color3.new(1, 0, 0)
})

local RainbowToggle = MainSection:AddToggle("RainbowToggle", {
    Title = "M√†u c·∫ßu v·ªìng",
    Default = false
})

local TeamCheckToggle = MainSection:AddToggle("TeamCheckToggle", {
    Title = "Ki·ªÉm tra ƒë·ªìng ƒë·ªôi",
    Default = false
})

ColorPicker:OnChanged(function(Color)
    if SkeletonESP then
        SkeletonESP.SetBoxColor(Color)
    end
end)


RainbowToggle:OnChanged(function(Value)
    if SkeletonESP then
        SkeletonESP.SetRainbowColor(Value)
    end
end)

TeamCheckToggle:OnChanged(function(Value)
    if SkeletonESP then
        SkeletonESP.SetTeamCheck(Value)
    end
end)

---------------------------------------------------------------------------- 
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

local espObjects = {}
local espEnabled = false
local espColor = Color3.new(1, 1, 1)
local espThickness = 20
local espTransparency = 1
local espTeamCheck = false
local espDistance = 1000

local function createDrawings()
    local box = Drawing.new("Square")
    box.Thickness = espThickness
    box.Color = espColor
    box.Filled = false
    box.Transparency = espTransparency
    box.Visible = false

    local name = Drawing.new("Text")
    name.Center = true
    name.Outline = true
    name.Color = espColor
    name.Font = 2
    name.Size = 13
    name.Visible = false

    return {box = box, name = name}
end

local function updateESP()
    if not espEnabled then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local vector, onScreen = camera:WorldToViewportPoint(hrp.Position)
                local distance = (hrp.Position - camera.CFrame.Position).Magnitude
                
                local esp = espObjects[player]
                if not esp then
                    esp = createDrawings()
                    espObjects[player] = esp
                end
                
                if onScreen and distance <= espDistance then
                    if not espTeamCheck or player.Team ~= localPlayer.Team then
                        local headPosition = camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 3, 0))
                        local legPosition = camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 3, 0))
                        local height = math.abs(headPosition.Y - legPosition.Y)
                        local width = height * 0.6
                        
                        esp.box.Size = Vector2.new(width, height)
                        esp.box.Position = Vector2.new(vector.X - width / 2, vector.Y - height / 2)
                        esp.box.Visible = true

                        esp.name.Text = string.format("%s\n%.0f studs", player.Name, distance)
                        esp.name.Position = Vector2.new(vector.X, vector.Y - height / 2 - 15)
                        esp.name.Visible = true
                    else
                        esp.box.Visible = false
                        esp.name.Visible = false
                    end
                else
                    esp.box.Visible = false
                    esp.name.Visible = false
                end
            else
                if espObjects[player] then
                    espObjects[player].box.Visible = false
                    espObjects[player].name.Visible = false
                end
            end
        end
    end
end

local function playerAdded(player)
    if player ~= localPlayer then
        espObjects[player] = createDrawings()
    end
end

local function playerRemoving(player)
    local esp = espObjects[player]
    if esp then
        esp.box:Remove()
        esp.name:Remove()
        espObjects[player] = nil
    end
end

local function cleanupESP()
    for _, esp in pairs(espObjects) do
        esp.box:Remove()
        esp.name:Remove()
    end
    espObjects = {}
end

Players.PlayerAdded:Connect(playerAdded)
Players.PlayerRemoving:Connect(playerRemoving)

local renderSteppedConnection

local EspToggle = MainSection:AddToggle("EspToggle", {
    Title = "ESP",
    Default = Configuration.Esp
})

EspToggle:OnChanged(function(Value)
    Configuration.Esp = Value
    espEnabled = Value
    if Value then
        renderSteppedConnection = RunService.RenderStepped:Connect(updateESP)
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer then
                playerAdded(player)
            end
        end
    else
        if renderSteppedConnection then
            renderSteppedConnection:Disconnect()
        end
        for _, esp in pairs(espObjects) do
            esp.box.Visible = false
            esp.name.Visible = false
        end
    end
end)

local EspColorPicker = MainSection:AddColorpicker("EspColor", {
    Title = "ESP Color",
    Default = espColor
})

EspColorPicker:OnChanged(function(Value)
    espColor = Value
    for _, esp in pairs(espObjects) do
        esp.box.Color = Value
        esp.name.Color = Value
    end
end)

local EspThicknessSlider = MainSection:AddSlider("EspThickness", {
    Title = "ESP Thickness",
    Default = espThickness,
    Min = 1,
    Max = 5,
    Rounding = 0,
    ValueName = "px"
})

EspThicknessSlider:OnChanged(function(Value)
    espThickness = Value
    for _, esp in pairs(espObjects) do
        esp.box.Thickness = Value
    end
end)

local EspTransparencySlider = MainSection:AddSlider("EspTransparency", {
    Title = "ESP Transparency",
    Default = espTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    ValueName = "alpha"
})

EspTransparencySlider:OnChanged(function(Value)
    espTransparency = Value
    for _, esp in pairs(espObjects) do
        esp.box.Transparency = Value
        esp.name.Transparency = Value
    end
end)

local EspTeamCheckToggle = MainSection:AddToggle("EspTeamCheck", {
    Title = "ESP Team Check",
    Default = espTeamCheck
})

EspTeamCheckToggle:OnChanged(function(Value)
    espTeamCheck = Value
end)

local EspDistanceSlider = MainSection:AddSlider("EspDistance", {
    Title = "ESP Distance",
    Default = espDistance,
    Min = 100,
    Max = 5000,
    Rounding = 0,
    ValueName = "studs"
})

EspDistanceSlider:OnChanged(function(Value)
    espDistance = Value
end)

game:GetService("CoreGui").ChildRemoved:Connect(function(child)
    if child.Name == "ScreenGui" then
        cleanupESP()
    end
end)

---------------------------------------------------------------------------- 
local healthBars = {}
local healthBarConnections = {}
local healthBarYOffset = 20
local healthBarEnabled = false
local healthBarWidth = 70
local healthBarHeight = 5
local healthBarOutlineThickness = 1
local healthBarTransparency = 0.5
local healthBarColor = Color3.new(0, 1, 0)  -- M√†u xanh l√° c√¢y m·∫∑c ƒë·ªãnh
local teamCheck = false  -- Th√™m bi·∫øn n√†y ƒë·ªÉ ki·ªÉm so√°t TeamCheck

local function CreateHealthBar(character)
    if healthBars[character] then return end
    
    local outline = Drawing.new("Square")
    outline.Thickness = healthBarOutlineThickness
    outline.Filled = false
    outline.Color = Color3.new(0, 0, 0)
    outline.Transparency = 1 - healthBarTransparency
    outline.Visible = false

    local background = Drawing.new("Square")
    background.Thickness = 1
    background.Filled = true
    background.Color = Color3.new(0.1, 0.1, 0.1)
    background.Transparency = healthBarTransparency
    background.Visible = false

    local bar = Drawing.new("Square")
    bar.Thickness = 1
    bar.Filled = true
    bar.Transparency = 1
    bar.Visible = false

    healthBars[character] = {outline = outline, background = background, bar = bar}
    print("Health bar created for character")
end

local function isEnemyPlayer(player)
    if not teamCheck then return true end
    if not Players.LocalPlayer.Team then return true end
    if not player.Team then return true end
    return player.Team ~= Players.LocalPlayer.Team
end

local function UpdateAllHealthBars()
    if not healthBarEnabled then return end

    for character, healthBarObjects in pairs(healthBars) do
        local humanoid = character:FindFirstChild("Humanoid")
        local head = character:FindFirstChild("Head")
        local player = Players:GetPlayerFromCharacter(character)

        if humanoid and head and humanoid.Health > 0 and player and player ~= Players.LocalPlayer then
            local isEnemy = isEnemyPlayer(player)
            
            if isEnemy then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                local headPos, onScreen = camera:WorldToViewportPoint(head.Position)

                if onScreen then
                    local barPosX = headPos.X - healthBarWidth/2
                    local barPosY = headPos.Y - healthBarYOffset

                    healthBarObjects.outline.Size = Vector2.new(healthBarWidth + 2, healthBarHeight + 2)
                    healthBarObjects.outline.Position = Vector2.new(barPosX - 1, barPosY - 1)
                    healthBarObjects.outline.Visible = true

                    healthBarObjects.background.Size = Vector2.new(healthBarWidth, healthBarHeight)
                    healthBarObjects.background.Position = Vector2.new(barPosX, barPosY)
                    healthBarObjects.background.Visible = true

                    healthBarObjects.bar.Size = Vector2.new(healthBarWidth * healthPercent, healthBarHeight)
                    healthBarObjects.bar.Position = Vector2.new(barPosX, barPosY)
                    healthBarObjects.bar.Color = healthBarColor:Lerp(Color3.new(1, 0, 0), 1 - healthPercent)
                    healthBarObjects.bar.Visible = true
                else
                    healthBarObjects.outline.Visible = false
                    healthBarObjects.background.Visible = false
                    healthBarObjects.bar.Visible = false
                end
            else
                healthBarObjects.outline.Visible = false
                healthBarObjects.background.Visible = false
                healthBarObjects.bar.Visible = false
            end
        else
            healthBarObjects.outline.Visible = false
            healthBarObjects.background.Visible = false
            healthBarObjects.bar.Visible = false
        end
    end
end

local function RemoveHealthBar(character)
    if healthBars[character] then
        healthBars[character].outline:Remove()
        healthBars[character].background:Remove()
        healthBars[character].bar:Remove()
        healthBars[character] = nil
        print("Health bar removed for character")
    end
end

local function SetupHealthBars()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player ~= Players.LocalPlayer then
            CreateHealthBar(player.Character)
        end
    end
end

local ThanhMauToggle = MainSection:AddToggle("mauToggle", {
    Title = "Thanh m√°u",
    Default = false
})

ThanhMauToggle:OnChanged(function(Value)
    healthBarEnabled = Value
    Configuration.mau = Value
    print("Thanh m√°u toggle changed to: " .. tostring(Value))
    
    if Value then
        SetupHealthBars()

        local function onCharacterAdded(character)
            if healthBarEnabled and character ~= Players.LocalPlayer.Character then
                CreateHealthBar(character)
            end
        end

        for _, player in ipairs(Players:GetPlayers()) do
            player.CharacterAdded:Connect(onCharacterAdded)
        end

        table.insert(healthBarConnections, Players.PlayerAdded:Connect(function(player)
            player.CharacterAdded:Connect(onCharacterAdded)
        end))
        
        table.insert(healthBarConnections, RunService.RenderStepped:Connect(UpdateAllHealthBars))
    else
        for _, connection in ipairs(healthBarConnections) do
            connection:Disconnect()
        end
        healthBarConnections = {}
        
        for character, _ in pairs(healthBars) do
            RemoveHealthBar(character)
        end
    end
end)

local TeamCheckToggle = MainSection:AddToggle("TeamCheckToggle", {
    Title = "Ki·ªÉm tra ƒë·ªìng ƒë·ªôi",
    Default = false
})

-- Th√™m ColorPicker cho m√†u thanh m√°u
local HealthBarColorPicker = MainSection:AddColorpicker("HealthBarColor", {
    Title = "M√†u thanh m√°u",
    Default = healthBarColor
})

HealthBarColorPicker:OnChanged(function(Value)
    healthBarColor = Value
end)

-- Th√™m Slider cho ƒë·ªô r·ªông thanh m√°u
local HealthBarWidthSlider = MainSection:AddSlider("HealthBarWidth", {
    Title = "ƒê·ªô r·ªông thanh m√°u",
    Default = healthBarWidth,
    Min = 30,
    Max = 150,
    Rounding = 0,
    ValueName = "px"
})

HealthBarWidthSlider:OnChanged(function(Value)
    healthBarWidth = Value
end)

-- Th√™m Slider cho ƒë·ªô trong su·ªët thanh m√°u
local HealthBarTransparencySlider = MainSection:AddSlider("HealthBarTransparency", {
    Title = "ƒê·ªô trong su·ªët thanh m√°u",
    Default = healthBarTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    ValueName = "transparency"
})

HealthBarTransparencySlider:OnChanged(function(Value)
    healthBarTransparency = Value
    for _, healthBarObject in pairs(healthBars) do
        healthBarObject.background.Transparency = Value
        healthBarObject.outline.Transparency = 1 - Value
    end
end)

-- Th√™m Slider cho kho·∫£ng c√°ch thanh m√°u t·ª´ ƒë·∫ßu nh√¢n v·∫≠t
local HealthBarOffsetSlider = MainSection:AddSlider("HealthBarOffset", {
    Title = "Kho·∫£ng c√°ch thanh m√°u",
    Default = healthBarYOffset,
    Min = 0,
    Max = 50,
    Rounding = 0,
    ValueName = "px"
})

HealthBarOffsetSlider:OnChanged(function(Value)
    healthBarYOffset = Value
end)

TeamCheckToggle:OnChanged(function(Value)
    teamCheck = Value
    print("Team Check changed to: " .. tostring(Value))
end)

---------------------------------------------------------------------------- 
local TeamColorEnabled = false
local ShowNamesEnabled = false
local NameSize = 14  -- K√≠ch th∆∞·ªõc m·∫∑c ƒë·ªãnh
local TeamCheckEnabled = false  -- Th√™m bi·∫øn n√†y ƒë·ªÉ ki·ªÉm so√°t TeamCheck

-- H√†m ƒë·ªÉ ki·ªÉm tra xem m·ªôt ng∆∞·ªùi ch∆°i c√≥ ph·∫£i l√† ƒë·ªëi th·ªß hay kh√¥ng
local function isEnemyPlayer(player)
    if not TeamCheckEnabled then return true end
    if not game.Players.LocalPlayer.Team then return true end
    if not player.Team then return true end
    return player.Team ~= game.Players.LocalPlayer.Team
end

-- H√†m ƒë·ªÉ c·∫≠p nh·∫≠t t√™n t√πy ch·ªânh
local function UpdateCustomName(player)
    local function updateForCharacter(character)
        if character then
            local humanoid = character:WaitForChild("Humanoid")
            if humanoid then
                humanoid.DisplayDistanceType = ShowNamesEnabled and Enum.HumanoidDisplayDistanceType.None or Enum.HumanoidDisplayDistanceType.Viewer
            end
            
            local head = character:WaitForChild("Head")
            if head then
                local nameGui = head:FindFirstChild("NameGui") or Instance.new("BillboardGui")
                nameGui.Name = "NameGui"
                nameGui.AlwaysOnTop = true
                nameGui.Size = UDim2.new(0, 100, 0, 40)
                nameGui.StudsOffset = Vector3.new(0, 2, 0)
                nameGui.Parent = head

                local nameLabel = nameGui:FindFirstChild("NameLabel") or Instance.new("TextLabel")
                nameLabel.Name = "NameLabel"
                nameLabel.Size = UDim2.new(1, 0, 1, 0)
                nameLabel.BackgroundTransparency = 1
                nameLabel.TextColor3 = Color3.new(1, 1, 1)
                nameLabel.TextStrokeTransparency = 0
                nameLabel.TextSize = NameSize
                nameLabel.Font = Enum.Font.SourceSansBold
                nameLabel.Parent = nameGui

                if ShowNamesEnabled and isEnemyPlayer(player) then
                    nameGui.Enabled = true
                    nameLabel.Text = player.Name
                    if player.Team then
                        nameLabel.TextColor3 = player.TeamColor.Color
                    end
                else
                    nameGui.Enabled = false
                end
            end
        end
    end

    if player.Character then
        updateForCharacter(player.Character)
    end

    player.CharacterAdded:Connect(updateForCharacter)
end

local function PlayerAdded(player)
    if player ~= game.Players.LocalPlayer then
        UpdateCustomName(player)
        player:GetPropertyChangedSignal("Team"):Connect(function()
            UpdateCustomName(player)
        end)
    end
end

local HientenToggle = MainSection:AddToggle("tenToggle", {
    Title = "Hi·ªÉn th·ªã t√™n",
    Default = Configuration.ten
})

HientenToggle:OnChanged(function(Value)
    Configuration.ShowNamesEnabled = Value
    ShowNamesEnabled = Value
    if Value then
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer then
                UpdateCustomName(player)
            end
        end
    end
    
    game.Players.PlayerAdded:Connect(PlayerAdded)

    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            PlayerAdded(player)
        end
    end
end)

-- Th√™m Toggle cho TeamCheck
local TeamCheckToggle = MainSection:AddToggle("TeamCheckToggle", {
    Title = "Ki·ªÉm tra ƒë·ªìng ƒë·ªôi",
    Default = false
})

TeamCheckToggle:OnChanged(function(Value)
    TeamCheckEnabled = Value
    print("Team Check changed to: " .. tostring(Value))
    -- C·∫≠p nh·∫≠t l·∫°i t√™n cho t·∫•t c·∫£ ng∆∞·ªùi ch∆°i
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            UpdateCustomName(player)
        end
    end
end)

-- Th√™m slider ƒë·ªÉ ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc t√™n
local NameSizeSlider = MainSection:AddSlider("NameSizeSlider", {
    Title = "K√≠ch th∆∞·ªõc t√™n",
    Min = 1,
    Max = 100,
    Default = 14,
    Step = 1,
    Rounding = 0,
    Callback = function(Value)
        NameSize = Value
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer and player.Character then
                local head = player.Character:FindFirstChild("Head")
                if head then
                    local nameGui = head:FindFirstChild("NameGui")
                    if nameGui then
                        local nameLabel = nameGui:FindFirstChild("NameLabel")
                        if nameLabel then
                            nameLabel.TextSize = Value
                        end
                    end
                end
            end
        end
    end
})

NameSizeSlider:SetValue(14)  -- ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh

---------------------------------------------------------------------------- 
local tracersObjects = {}
local tracersEnabled = false
local tracersPosition = "D∆∞·ªõi"
local tracerColor = Color3.new(0.4, 0.7, 1)
local tracerThickness = 1
local tracerTransparency = 1
local enemyNearWarningEnabled = false
local enemyNearDistance = 20
local enemyFarDistance = 50
local rainbowColorEnabled = false
local teamCheck = false

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

local function taoTracer()
    local tracer = Drawing.new("Line")
    tracer.Thickness = tracerThickness
    tracer.Color = tracerColor
    tracer.Transparency = tracerTransparency
    return tracer
end

local function layViTriTracer()
    local kichThuocManHinh = camera.ViewportSize
    local viTri = Vector2.new(kichThuocManHinh.X / 2, kichThuocManHinh.Y)
    
    if tracersPosition == "Tr√™n" then
        viTri = Vector2.new(kichThuocManHinh.X / 2, 0)
    elseif tracersPosition == "Gi·ªØa" then
        viTri = Vector2.new(kichThuocManHinh.X / 2, kichThuocManHinh.Y / 2)
    elseif tracersPosition == "Tr√°i" then
        viTri = Vector2.new(0, kichThuocManHinh.Y / 2)
    elseif tracersPosition == "Ph·∫£i" then
        viTri = Vector2.new(kichThuocManHinh.X, kichThuocManHinh.Y / 2)
    end
    
    return viTri
end

local function getRainbowColor()
    local time = tick() * 0.5
    return Color3.fromHSV(time % 1, 1, 1)
end

local function isEnemyPlayer(player)
    if not teamCheck then return true end
    if not localPlayer.Team then return true end
    if not player.Team then return true end
    return player.Team ~= localPlayer.Team
end

local enemyWarningText = Drawing.new("Text")
enemyWarningText.Visible = false
enemyWarningText.Size = 24
enemyWarningText.Center = true
enemyWarningText.Outline = true
enemyWarningText.OutlineColor = Color3.new(0, 0, 0)
enemyWarningText.Position = Vector2.new(camera.ViewportSize.X / 2, 50)

local function capNhatTracers()
    if not tracersEnabled then return end
    
    local diemBatDauTracer = layViTriTracer()
    local closestEnemyDistance = math.huge
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local tracer = tracersObjects[player]
            local isEnemy = isEnemyPlayer(player)
            
            if isEnemy then
                if not tracer then
                    tracer = taoTracer()
                    tracersObjects[player] = tracer
                end
            
            local character = player.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    local vector, trongManHinh = camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
                    local distance = (character.HumanoidRootPart.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
                    
                    if trongManHinh then
                        tracer.From = diemBatDauTracer
                        tracer.To = Vector2.new(vector.X, vector.Y)
                        tracer.Visible = true
                        
                        if rainbowColorEnabled then
                            tracer.Color = getRainbowColor()
                        else
                            tracer.Color = tracerColor
                        end
                        
                        if distance < closestEnemyDistance then
                            closestEnemyDistance = distance
                        end
                    else
                        tracer.Visible = false
                    end
                else
                    tracer.Visible = false
                end
            else
                if tracer then
                    tracer.Visible = false
                end
            end
        end
    end
    
    if enemyNearWarningEnabled then
        if closestEnemyDistance <= enemyNearDistance then
            enemyWarningText.Text = "C·∫¢NH B√ÅO‚ö†Ô∏è: ƒê·ªãch ·ªü g·∫ßn!"
            enemyWarningText.Color = Color3.new(1, 0, 0)
            enemyWarningText.Visible = true
        elseif closestEnemyDistance <= enemyFarDistance then
            enemyWarningText.Text = "Ch√∫ √ΩüèÉ: ƒê·ªãch ƒëang t·ªõi g·∫ßn"
            enemyWarningText.Color = Color3.new(1, 1, 0)
            enemyWarningText.Visible = true
        else
            enemyWarningText.Visible = false
        end
    else
        enemyWarningText.Visible = false
    end
end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and not tracersObjects[player] and isEnemyPlayer(player) then
            tracersObjects[player] = taoTracer()
        end
    end

local TracersDropdown = MainSection:AddDropdown("TracersDropdown", {
    Title = "ƒê∆∞·ªùng k·∫ª",
    Values = {"T·∫Øt", "Tr√™n", "D∆∞·ªõi", "Gi·ªØa", "Tr√°i", "Ph·∫£i"},
    Multi = false,
    Default = 1,
})

TracersDropdown:OnChanged(function(Value)
    if Value == "T·∫Øt" then
        tracersEnabled = false
        for _, tracer in pairs(tracersObjects) do
            tracer.Visible = false
        end
    else
        tracersEnabled = true
        tracersPosition = Value
    end
    Configuration.Tracers = tracersEnabled
    Configuration.TracersPosition = Value
end)

local TracerColorPicker = MainSection:AddColorpicker("TracerColor", {
    Title = "M√†u ƒë∆∞·ªùng k·∫ª",
    Default = tracerColor
})

TracerColorPicker:OnChanged(function(Value)
    tracerColor = Value
    for _, tracer in pairs(tracersObjects) do
        tracer.Color = tracerColor
    end
end)

local TracerThicknessSlider = MainSection:AddSlider("TracerThickness", {
    Title = "ƒê·ªô d√†y ƒë∆∞·ªùng k·∫ª",
    Default = tracerThickness,
    Min = 1,
    Max = 5,
    Rounding = 1,
    ValueName = "px"
})

TracerThicknessSlider:OnChanged(function(Value)
    tracerThickness = Value
    for _, tracer in pairs(tracersObjects) do
        tracer.Thickness = tracerThickness
    end
end)

local TracerTransparencySlider = MainSection:AddSlider("TracerTransparency", {
    Title = "ƒê·ªô trong su·ªët ƒë∆∞·ªùng k·∫ª",
    Default = tracerTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    ValueName = "transparency"
})

TracerTransparencySlider:OnChanged(function(Value)
    tracerTransparency = Value
    for _, tracer in pairs(tracersObjects) do
        tracer.Transparency = tracerTransparency
    end
end)

local EnemyWarningToggle = MainSection:AddToggle("EnemyWarningToggle", {
    Title = "C·∫£nh b√°o ƒë·ªãch g·∫ßn",
    Default = false
})

EnemyWarningToggle:OnChanged(function(Value)
    enemyNearWarningEnabled = Value
end)

local RainbowColorToggle = MainSection:AddToggle("RainbowColorToggle", {
    Title = "M√†u c·∫ßu v·ªìng",
    Default = false
})

RainbowColorToggle:OnChanged(function(Value)
    rainbowColorEnabled = Value
end)

local TeamCheckToggle = MainSection:AddToggle("TeamCheckToggle", {
    Title = "Ki·ªÉm tra ƒë·ªìng ƒë·ªôi",
    Default = false
})

TeamCheckToggle:OnChanged(function(Value)
    teamCheck = Value
end)

local EnemyNearDistanceSlider = MainSection:AddSlider("EnemyNearDistance", {
    Title = "Kho·∫£ng c√°ch c·∫£nh b√°o g·∫ßn",
    Default = enemyNearDistance,
    Min = 5,
    Max = 100,
    Rounding = 0,
    ValueName = "studs"
})

EnemyNearDistanceSlider:OnChanged(function(Value)
    enemyNearDistance = Value
end)

local EnemyFarDistanceSlider = MainSection:AddSlider("EnemyFarDistance", {
    Title = "Kho·∫£ng c√°ch c·∫£nh b√°o xa",
    Default = enemyFarDistance,
    Min = 20,
    Max = 200,
    Rounding = 0,
    ValueName = "studs"
})

EnemyFarDistanceSlider:OnChanged(function(Value)
    enemyFarDistance = Value
end)

RunService.RenderStepped:Connect(capNhatTracers)

local function donDepTracers()
    for _, tracer in pairs(tracersObjects) do
        tracer:Remove()
    end
    tracersObjects = {}
    enemyWarningText:Remove()
end

local function playerRemoving(player)
    if tracersObjects[player] then
        tracersObjects[player]:Remove()
        tracersObjects[player] = nil
    end
end

Players.PlayerRemoving:Connect(playerRemoving)
---------------------------------------------------------------------------- 
local player = Players.LocalPlayer


local espObjects = {}
local highlightEnabled = false
local boxColor = Color3.new(1, 0, 0) -- Default red color
local boxTransparency = 0.5 -- Default transparency
local boxOutlineTransparency = 0 -- Default outline transparency

local function createESPObjects()
    local esp = {
        highlight = Instance.new("Highlight")
    }
    esp.highlight.FillColor = boxColor
    esp.highlight.OutlineColor = Color3.new(1, 1, 1) -- White outline
    esp.highlight.FillTransparency = boxTransparency
    esp.highlight.OutlineTransparency = boxOutlineTransparency
    esp.highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    return esp
end

local function updateESPProperties()
    for _, esp in pairs(espObjects) do
        esp.highlight.FillColor = boxColor
        esp.highlight.FillTransparency = boxTransparency
        esp.highlight.OutlineTransparency = boxOutlineTransparency
    end
end

local function updateESP()
    for player, esp in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if highlightEnabled then
                esp.highlight.Parent = player.Character
                esp.highlight.Enabled = true
            else
                esp.highlight.Enabled = false
            end
        else
            esp.highlight.Enabled = false
        end
    end
end

local function playerAdded(player)
    if player ~= localPlayer then
        espObjects[player] = createESPObjects()
    end
end

local function playerRemoving(player)
    if espObjects[player] then
        espObjects[player].highlight:Destroy()
        espObjects[player] = nil
    end
end

Players.PlayerAdded:Connect(playerAdded)
Players.PlayerRemoving:Connect(playerRemoving)

local renderSteppedConnection

local HighToggle = MainSection:AddToggle("HLToggle", {
    Title = "Highlight ESP",
    Default = Configuration.HL
})

HighToggle:OnChanged(function(Value)
    Configuration.HL = Value
    highlightEnabled = Value
    if Value then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and not espObjects[player] then
                playerAdded(player)
            end
        end
        updateESPProperties()
        if not renderSteppedConnection then
            renderSteppedConnection = RunService.RenderStepped:Connect(updateESP)
        end
    else
        if renderSteppedConnection then
            renderSteppedConnection:Disconnect()
            renderSteppedConnection = nil
        end
        for _, esp in pairs(espObjects) do
            esp.highlight.Enabled = false
        end
    end
end)

-- Color Picker for Highlight ESP
local ColorPicker = MainSection:AddColorpicker("BoxColor", {
    Title = "ESP Color",
    Default = Color3.new(1, 0, 0)
})

ColorPicker:OnChanged(function(Value)
    boxColor = Value
    updateESPProperties()
end)

-- Transparency Slider for Highlight ESP
local TransparencySlider = MainSection:AddSlider("BoxTransparency", {
    Title = "ESP Transparency",
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    ValueName = "transparency"
})

TransparencySlider:OnChanged(function(Value)
    boxTransparency = Value
    updateESPProperties()
end)

-- Outline Transparency Slider for Highlight ESP
local OutlineTransparencySlider = MainSection:AddSlider("BoxOutlineTransparency", {
    Title = "ESP Outline Transparency",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    ValueName = "transparency"
})

OutlineTransparencySlider:OnChanged(function(Value)
    boxOutlineTransparency = Value
    updateESPProperties()
end)
---------------------------------------------------------------------------- 
local espObjects = {}
local espEnabled = false
local boxColor = Color3.new(1, 0, 0) -- M√†u ƒë·ªè m·∫∑c ƒë·ªãnh
local boxTransparency = 0.5 -- ƒê·ªô trong su·ªët m·∫∑c ƒë·ªãnh
local boxOutlineTransparency = 0 -- ƒê·ªô trong su·ªët c·ªßa vi·ªÅn
local boxThickness = 0.1 -- ƒê·ªô d√†y c·ªßa box

local function create3DBox()
    local box = Instance.new("Model")
    for i = 1, 12 do
        local edge = Instance.new("Part")
        edge.Name = "Edge" .. i
        edge.Size = Vector3.new(boxThickness, boxThickness, 1)
        edge.Anchored = true
        edge.CanCollide = false
        edge.Color = boxColor
        edge.Transparency = boxTransparency
        edge.Material = Enum.Material.Neon -- L√†m cho box ph√°t s√°ng
        
        -- Th√™m SurfaceGui ƒë·ªÉ t·∫°o vi·ªÅn
        local surfaceGui = Instance.new("SurfaceGui")
        surfaceGui.Face = Enum.NormalId.Front
        surfaceGui.LightInfluence = 0
        surfaceGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        surfaceGui.AlwaysOnTop = true
        surfaceGui.Parent = edge

        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BorderSizePixel = 0
        frame.BackgroundTransparency = boxOutlineTransparency
        frame.BackgroundColor3 = Color3.new(1, 1, 1) -- M√†u vi·ªÅn tr·∫Øng
        frame.Parent = surfaceGui

        edge.Parent = box
    end
    return box
end

local function updateBoxProperties()
    for _, esp in pairs(espObjects) do
        for i = 1, 12 do
            local edge = esp["Edge" .. i]
            edge.Color = boxColor
            edge.Transparency = boxTransparency
            edge.Size = Vector3.new(boxThickness, boxThickness, edge.Size.Z)
            
            local frame = edge.SurfaceGui.Frame
            frame.BackgroundTransparency = boxOutlineTransparency
        end
    end
end

local function updateESP()
    for player, esp in pairs(espObjects) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local hrp = character.HumanoidRootPart
            local head = character:FindFirstChild("Head")
            if head then
                if espEnabled then
                    esp.Parent = camera  -- Parent to camera to make it render on top
                    
                    local size = character:GetExtentsSize()
                    local position = hrp.Position

                    -- Define the 8 corners of the box
                    local corners = {
                        Vector3.new(-size.X/2, -size.Y/2, -size.Z/2),
                        Vector3.new(size.X/2, -size.Y/2, -size.Z/2),
                        Vector3.new(-size.X/2, size.Y/2, -size.Z/2),
                        Vector3.new(size.X/2, size.Y/2, -size.Z/2),
                        Vector3.new(-size.X/2, -size.Y/2, size.Z/2),
                        Vector3.new(size.X/2, -size.Y/2, size.Z/2),
                        Vector3.new(-size.X/2, size.Y/2, size.Z/2),
                        Vector3.new(size.X/2, size.Y/2, size.Z/2)
                    }

                    -- Update the 12 edges
                    local function updateEdge(index, start, stop)
                        local edge = esp["Edge" .. index]
                        edge.Size = Vector3.new(boxThickness, boxThickness, (stop - start).Magnitude)
                        edge.CFrame = CFrame.new(position + (start + stop)/2, position + stop)
                    end

                    -- Vertical edges
                    updateEdge(1, corners[1], corners[3])
                    updateEdge(2, corners[2], corners[4])
                    updateEdge(3, corners[5], corners[7])
                    updateEdge(4, corners[6], corners[8])

                    -- Top edges
                    updateEdge(5, corners[3], corners[4])
                    updateEdge(6, corners[3], corners[7])
                    updateEdge(7, corners[7], corners[8])
                    updateEdge(8, corners[4], corners[8])

                    -- Bottom edges
                    updateEdge(9, corners[1], corners[2])
                    updateEdge(10, corners[1], corners[5])
                    updateEdge(11, corners[5], corners[6])
                    updateEdge(12, corners[2], corners[6])
                else
                    esp.Parent = nil
                end
            end
        else
            esp.Parent = nil
        end
    end
end

local function playerAdded(player)
    if player ~= localPlayer then
        espObjects[player] = create3DBox()
    end
end

-- Handle player leaving
local function playerRemoving(player)
    if espObjects[player] then
        espObjects[player]:Destroy()
        espObjects[player] = nil
    end
end

-- Connect events
Players.PlayerAdded:Connect(playerAdded)
Players.PlayerRemoving:Connect(playerRemoving)

-- Connect update function to RenderStepped
local renderSteppedConnection

local Box3Toggle = MainSection:AddToggle("b3Toggle", {
    Title = "Box 3D",
    Default = Configuration.b3
})

Box3Toggle:OnChanged(function(Value)
    Configuration.Box3 = Value
    espEnabled = Value
    if Value then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and not espObjects[player] then
                playerAdded(player)
            end
        end
        updateBoxProperties() -- √Åp d·ª•ng thu·ªôc t√≠nh hi·ªán t·∫°i
        if not renderSteppedConnection then
            renderSteppedConnection = RunService.RenderStepped:Connect(updateESP)
        end
    else
        if renderSteppedConnection then
            renderSteppedConnection:Disconnect()
            renderSteppedConnection = nil
        end
        for _, esp in pairs(espObjects) do
            esp.Parent = nil
        end
    end
end)

-- Th√™m ColorPicker cho Box 3D
local ColorPicker = MainSection:AddColorpicker("BoxColor", {
    Title = "M√†u Box 3D",
    Default = Color3.new(1, 0, 0)
})

ColorPicker:OnChanged(function(Value)
    boxColor = Value
    updateBoxProperties()
end)

-- Th√™m Slider cho ƒë·ªô trong su·ªët c·ªßa Box
local TransparencySlider = MainSection:AddSlider("BoxTransparency", {
    Title = "ƒê·ªô trong su·ªët Box",
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    ValueName = "transparency"
})

TransparencySlider:OnChanged(function(Value)
    boxTransparency = Value
    updateBoxProperties()
end)

-- Th√™m Slider cho ƒë·ªô d√†y c·ªßa Box
local ThicknessSlider = MainSection:AddSlider("BoxThickness", {
    Title = "ƒê·ªô d√†y Box",
    Default = 0.1,
    Min = 0.01,
    Max = 0.5,
    Rounding = 2,
    ValueName = "thickness"
})

ThicknessSlider:OnChanged(function(Value)
    boxThickness = Value
    updateBoxProperties()
end)

-- Th√™m Toggle cho xuy√™n ƒë·ªãa h√¨nh
local WallhackToggle = MainSection:AddToggle("WallhackToggle", {
    Title = "Xuy√™n ƒë·ªãa h√¨nh",
    Default = false
})

WallhackToggle:OnChanged(function(Value)
    for _, esp in pairs(espObjects) do
        for i = 1, 12 do
            local edge = esp["Edge" .. i]
            edge.LocalTransparencyModifier = Value and 0 or 1
        end
    end
end)

-- Th√™m Toggle cho box ph√°t s√°ng
local GlowToggle = MainSection:AddToggle("GlowToggle", {
    Title = "Box ph√°t s√°ng",
    Default = true
})

GlowToggle:OnChanged(function(Value)
    for _, esp in pairs(espObjects) do
        for i = 1, 12 do
            local edge = esp["Edge" .. i]
            edge.Material = Value and Enum.Material.Neon or Enum.Material.SmoothPlastic
        end
    end
end)

-- Th√™m Slider cho ƒë·ªô trong su·ªët c·ªßa vi·ªÅn Box
local OutlineTransparencySlider = MainSection:AddSlider("OutlineTransparency", {
    Title = "ƒê·ªô trong su·ªët vi·ªÅn",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    ValueName = "transparency"
})

OutlineTransparencySlider:OnChanged(function(Value)
    boxOutlineTransparency = Value
    updateBoxProperties()
end)
----------------------------------------------------------------------------
local AimToggle = TeamSection:AddToggle("AIToggle", {
    Title = "Aimbot",
    Default = Configuration.AI
})

-- ƒê·ªãnh nghƒ©a c√°c bi·∫øn ·ªü ph·∫°m vi r·ªông h∆°n
local AimbotEnabled = false
local connection
local FOVCircle
local IgnoreWalls = false

-- Th√™m c√°c bi·∫øn m·ªõi
local FOVRadius = 100
local currentAimbotRange = 100
local minTargetHealth = 0
local FOVOffset = Vector2.new(0, 0)
local AimbotSpeed = 1
local TeamCheck = false
local WallcheckEnabled = true  -- Th√™m bi·∫øn m·ªõi cho wallcheck

-- Th√™m ColorPicker cho FOV
local FovColorPicker = TeamSection:AddColorpicker("FovColor", {
    Title = "M√†u Fov",
    Default = Color3.new(1, 1, 1)
})

-- Th√™m Dropdown cho kho·∫£ng Aimbot
local AimbotRangeDropdown = TeamSection:AddDropdown("AimbotRange", {
    Title = "Kho·∫£ng c√°ch Aimbot",
    Values = {"Aimbot B√¨nh Th∆∞·ªùng", "Aimbot Xa", "Aimbot G·∫ßn"},
    Default = "Aimbot Xa",
})

local currentAimbotRange = 200  -- Gi√° tr·ªã m·∫∑c ƒë·ªãnh, t∆∞∆°ng ·ª©ng v·ªõi "Aimbot Xa"

local AimbotRanges = {
    ["Aimbot Max Xa"] = math.huge,
    ["Aimbot Xa 2000M"] = 2000,
    ["Aimbot G·∫ßn 200M"] = 200
}

-- Th√™m Slider cho m√°u m·ª•c ti√™u t·ªëi thi·ªÉu
local TargetHealthSlider = TeamSection:AddSlider("TargetHealth", {
    Title = "Aimbot theo l∆∞·ª£ng m√°u",
    Default = 0,
    Min = 0,
    Max = 100,
    Rounding = 0,
    ValueName = "%"
})

-- Th√™m Toggle ƒë·ªÉ hi·ªÉn th·ªã FOV
local ShowFovToggle = TeamSection:AddToggle("ShowFov", {
    Title = "Hi·ªán v√≤ng Fov",
    Default = true
})

-- Th√™m Slider cho k√≠ch th∆∞·ªõc FOV
local FOVSizeSlider = TeamSection:AddSlider("FOVSize", {
    Title = "K√≠ch th∆∞·ªõc Fov",
    Default = 100,
    Min = 10,
    Max = 500,
    Rounding = 0,
    ValueName = "px"
})

-- Th√™m Slider cho v·ªã tr√≠ FOV theo chi·ªÅu ngang
local FOVHorizontalSlider = TeamSection:AddSlider("FOVHorizontal", {
    Title = "Tr√°i ph·∫£i Fov",
    Default = 0,
    Min = -500,
    Max = 500,
    Rounding = 0,
    ValueName = "px"
})

-- Th√™m Slider cho v·ªã tr√≠ FOV theo chi·ªÅu d·ªçc
local FOVVerticalSlider = TeamSection:AddSlider("FOVVertical", {
    Title = "Cao th·∫•p Fov",
    Default = 0,
    Min = -500,
    Max = 500,
    Rounding = 0,
    ValueName = "px"
})

-- Th√™m Slider cho t·ªëc ƒë·ªô Aimbot
local AimbotSpeedSlider = TeamSection:AddSlider("AimbotSpeed", {
    Title = "T·ªëc ƒë·ªô Aimbot",
    Default = 1,
    Min = 0.1,
    Max = 50,
    Rounding = 1,
    ValueName = "x"
})

-- Th√™m Toggle cho Team Check
local TeamCheckToggle = TeamSection:AddToggle("TeamCheck", {
    Title = "Team Check",
    Default = false
})

-- Th√™m Toggle cho Wallcheck
local WallcheckToggle = TeamSection:AddToggle("WallcheckToggle", {
    Title = "Wallcheck",
    Default = true
})

AimToggle:OnChanged(function(Value)
    Configuration.AimbotEnabled = Value
    AimbotEnabled = Value

    if Value then
        -- ƒê·∫£m b·∫£o Camera ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a
        local Camera = workspace.CurrentCamera
        if not Camera then return end

        -- T·∫°o FOV Circle
        FOVCircle = Drawing.new("Circle")
        FOVCircle.Visible = ShowFovToggle.Value
        FOVCircle.Thickness = 1
        FOVCircle.Color = FovColorPicker.Value
        FOVCircle.Filled = false
        FOVCircle.Transparency = 1
        FOVCircle.NumSides = 60
        FOVCircle.Radius = FOVRadius

        -- C·∫≠p nh·∫≠t v·ªã tr√≠ FOV Circle
        local function UpdateFOVCircle()
            if Camera and Camera.ViewportSize then
                FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) + FOVOffset
            end
        end

        -- Ki·ªÉm tra xem m·ª•c ti√™u c√≥ trong FOV kh√¥ng
        local function IsInFOV(position)
            if not Camera then return false end
            local screenPosition, onScreen = Camera:WorldToScreenPoint(position)
            if not onScreen then return false end
            
            local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) + FOVOffset
            return (Vector2.new(screenPosition.X, screenPosition.Y) - screenCenter).Magnitude <= FOVRadius
        end

        -- H√†m ki·ªÉm tra t·∫ßm nh√¨n
        local function HasLineOfSight(target)
            if not WallcheckEnabled then return true end
            local ray = Ray.new(Camera.CFrame.Position, (target.Position - Camera.CFrame.Position).Unit * 1000)
            local part, position = workspace:FindPartOnRayWithIgnoreList(ray, {game.Players.LocalPlayer.Character})
            return part == target or (position - target.Position).Magnitude < 5
        end

        -- L·∫•y ƒë·∫ßu c·ªßa ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t trong FOV v√† c√≥ t·∫ßm nh√¨n
        local function GetClosestPlayerHead()
            local closestPlayer = nil
            local shortestDistance = math.huge
            local localPlayer = game.Players.LocalPlayer

            for _, player in pairs(game.Players:GetPlayers()) do
                if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Head") and player.Character:FindFirstChild("Humanoid") then
                    local head = player.Character.Head
                    local humanoid = player.Character.Humanoid
                    
                    if (not TeamCheck or player.Team ~= localPlayer.Team) and
                       IsInFOV(head.Position) and 
                       humanoid.Health > 0 and
                       humanoid.Health >= minTargetHealth and
                       HasLineOfSight(head) then
                        
                        local distance = (head.Position - Camera.CFrame.Position).Magnitude
                        if distance <= currentAimbotRange and distance < shortestDistance then
                            closestPlayer = player
                            shortestDistance = distance
                        end
                    end
                end
            end

            return closestPlayer and closestPlayer.Character.Head
        end

-- H√†m Aimbot
        local function Aimbot()
            local targetHead = GetClosestPlayerHead()
            if targetHead and Camera then
                local targetPos = targetHead.Position
                local currentCFrame = Camera.CFrame
                local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)
                Camera.CFrame = currentCFrame:Lerp(targetCFrame, AimbotSpeed * 0.1)
            end
        end

        -- Loop ch√≠nh
        if connection then connection:Disconnect() end
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if AimbotEnabled then
                UpdateFOVCircle()
                Aimbot()
            end
        end)
    else
        -- Logic khi t·∫Øt Aimbot
        if connection then
            connection:Disconnect()
            connection = nil
        end
        if FOVCircle then
            FOVCircle:Remove()
            FOVCircle = nil
        end
    end
end)

-- X·ª≠ l√Ω c√°c s·ª± ki·ªán cho c√°c ph·∫ßn t·ª≠ UI
FovColorPicker:OnChanged(function(Value)
    if FOVCircle then
        FOVCircle.Color = Value
    end
end)

AimbotRangeDropdown:OnChanged(function(Value)
    currentAimbotRange = AimbotRanges[Value] or math.huge
end)

TargetHealthSlider:OnChanged(function(Value)
    minTargetHealth = Value
end)

ShowFovToggle:OnChanged(function(Value)
    if FOVCircle then
        FOVCircle.Visible = Value
    end
end)

FOVSizeSlider:OnChanged(function(Value)
    FOVRadius = Value
    if FOVCircle then
        FOVCircle.Radius = Value
    end
end)

FOVHorizontalSlider:OnChanged(function(Value)
    FOVOffset = Vector2.new(Value, FOVOffset.Y)
    if FOVCircle then
        UpdateFOVCircle()
    end
end)

FOVVerticalSlider:OnChanged(function(Value)
    FOVOffset = Vector2.new(FOVOffset.X, Value)
    if FOVCircle then
        UpdateFOVCircle()
    end
end)

AimbotSpeedSlider:OnChanged(function(Value)
    AimbotSpeed = Value
end)

TeamCheckToggle:OnChanged(function(Value)
    TeamCheck = Value
end)

-- Th√™m x·ª≠ l√Ω s·ª± ki·ªán cho WallcheckToggle
WallcheckToggle:OnChanged(function(Value)
    WallcheckEnabled = Value
end)
---------------------------------------------------------------------------- 
local SilentAimEnabled = false
local PredictionEnabled = false
local PredictionMode = "Dynamic"
local PredictionAmount = 0.165
local AimbotEnabled = false

local AimSToggle = TeamSection:AddToggle("SAimToggle", {
    Title = "Silent Aim",
    Default = Configuration.SAim
})

local ModeDropdown = TeamSection:AddDropdown("ModeDropdown", {
    Title = "Prediction Mode",
    Values = {"Dynamic", "Static"},
    Multi = false,
    Default = 1,
})

local PredictionToggle = TeamSection:AddToggle("PredictionToggle", {
    Title = "Aim Prediction",
    Default = false
})

local PredictionAmountSlider = TeamSection:AddSlider("PredictionAmount", {
    Title = "Prediction Amount",
    Default = 0.165,
    Min = 0,
    Max = 1,
    Rounding = 3,
    ValueName = "s"
})

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function SimulateTouchInput()
    local touchPosition = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    UserInputService:SendTouchEvent(Enum.UserInputState.Begin, touchPosition, 0)
    task.wait(0.1)
    UserInputService:SendTouchEvent(Enum.UserInputState.End, touchPosition, 0)
end

local function IsTargetVisible(target)
    local character = LocalPlayer.Character
    local head = character and (character:FindFirstChild("Head") or character:FindFirstChild("UpperTorso") or character:FindFirstChildWhichIsA("BasePart"))
    
    if not head then return false end

    local ray = Ray.new(
        head.Position,
        (target.Position - head.Position).Unit * 1000
    )
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {character, target.Parent}
    params.FilterType = Enum.RaycastFilterType.Blacklist

    local result = workspace:Raycast(ray.Origin, ray.Direction, params)
    return result and (result.Position - target.Position).Magnitude < 5
end

local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local localCharacter = LocalPlayer.Character
    local localHumanoidRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    
    if not localHumanoidRootPart then return nil end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart and IsTargetVisible(humanoidRootPart) then
                local distance = (humanoidRootPart.Position - localHumanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function GetPredictedPosition(player)
    if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end

    if not PredictionEnabled then
        return player.Character.HumanoidRootPart.Position
    end

    local velocity = player.Character.HumanoidRootPart.Velocity
    local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
    
    if PredictionMode == "Dynamic" then
        local timeToHit = distance / 1000
        return player.Character.HumanoidRootPart.Position + (velocity * timeToHit)
    else
        return player.Character.HumanoidRootPart.Position + (velocity * PredictionAmount)
    end
end

local function SilentAim()
    local closestPlayer = GetClosestPlayer()
    if not closestPlayer then return end

    local targetPart = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    local predictedPosition = GetPredictedPosition(closestPlayer)
    if not predictedPosition then return end
    
    local randomOffset = Vector3.new(
        math.random(-10, 10) / 100,
        math.random(-10, 10) / 100,
        math.random(-10, 10) / 100
    )
    local targetPosition = predictedPosition + randomOffset
    
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()

        if SilentAimEnabled and method == "FireServer" and self.Name == "WeaponRemote" then
            args[2] = targetPosition
        end

        return oldNamecall(self, unpack(args))
    end))
end

local smoothnessFactor = 0.8

local function SmoothAdjustBulletTrajectory(bullet, targetPosition)
    local currentDirection = bullet.CFrame.LookVector
    local targetDirection = (targetPosition - bullet.Position).Unit
    local smoothedDirection = currentDirection:Lerp(targetDirection, smoothnessFactor)
    
    bullet.CFrame = CFrame.new(bullet.Position, bullet.Position + smoothedDirection)
    bullet.Velocity = smoothedDirection * bullet.Velocity.Magnitude
end

local adjustedBullets = {}

local function TeleportBulletToTarget(bullet)
    local closestPlayer = GetClosestPlayer()
    if not closestPlayer then return end

    local targetPart = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    local distance = (targetPart.Position - bullet.Position).Magnitude
    if distance < 10 then
        local randomOffset = Vector3.new(
            math.random(-20, 20) / 100,
            math.random(-20, 20) / 100,
            math.random(-20, 20) / 100
        )
        bullet.Position = targetPart.Position + randomOffset
    end
end

local maxAngle = math.rad(30)

local function LimitAngle(currentDirection, targetDirection)
    local angle = math.acos(currentDirection:Dot(targetDirection))
    if angle > maxAngle then
        local axis = currentDirection:Cross(targetDirection).Unit
        return CFrame.fromAxisAngle(axis, maxAngle) * currentDirection
    end
    return targetDirection
end

local function AutoFire()
    if not SilentAimEnabled then return end

    local closestPlayer = GetClosestPlayer()
    if not closestPlayer then return end

    ReplicatedStorage.WeaponRemote:FireServer()
end

local updateInterval = 0.1
local lastUpdateTime = 0

local function UpdateSilentAim()
    local currentTime = tick()
    if currentTime - lastUpdateTime < updateInterval then
        return
    end
    lastUpdateTime = currentTime

    local closestPlayer = GetClosestPlayer()
    if not closestPlayer then return end

    local targetPart = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    local predictedPosition = GetPredictedPosition(closestPlayer)
    if not predictedPosition then return end

    for _, bullet in ipairs(workspace:GetDescendants()) do
        if bullet:IsA("Part") and bullet.Name == "Bullet" then
            local currentDirection = bullet.CFrame.LookVector
            local targetDirection = (predictedPosition - bullet.Position).Unit
            local limitedDirection = LimitAngle(currentDirection, targetDirection)
            
            SmoothAdjustBulletTrajectory(bullet, bullet.Position + limitedDirection)
            TeleportBulletToTarget(bullet)
        end
    end

    SimulateTouchInput()
    AutoFire()
end

local function UpdateSilentAimCoroutine()
    while SilentAimEnabled do
        UpdateSilentAim()
        RunService.Heartbeat:Wait()
    end
end

AimSToggle:OnChanged(function(Value)
    SilentAimEnabled = Value
    Configuration.SAim = Value
    if Value then
        coroutine.wrap(UpdateSilentAimCoroutine)()
    end
end)

PredictionToggle:OnChanged(function(Value)
    PredictionEnabled = Value
end)

ModeDropdown:OnChanged(function(Value)
    PredictionMode = Value
    PredictionAmountSlider.Visible = (Value == "Static")
end)

PredictionAmountSlider:OnChanged(function(Value)
    PredictionAmount = Value
end)

-- Th√™m m·ªôt s·ªë t√≠nh nƒÉng m·ªõi

local function CalculateLeadshot(targetPosition, targetVelocity, projectileSpeed)
    local distance = (targetPosition - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
    local timeToHit = distance / projectileSpeed
    return targetPosition + targetVelocity * timeToHit
end

local function ApplyBulletDrop(bullet, initialVelocity, gravity)
    local elapsedTime = tick() - bullet.CreationTime
    local dropAmount = 0.5 * gravity * elapsedTime^2
    bullet.Position = bullet.Position - Vector3.new(0, dropAmount, 0)
end

local projectileSpeed = 1000 -- Adjust this value based on the game's weapon projectile speed
local gravity = Vector3.new(0, -9.81, 0)

RunService.Heartbeat:Connect(function()
    if SilentAimEnabled then
        local closestPlayer = GetClosestPlayer()
        if closestPlayer then
            local targetPart = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetPart then
                local targetPosition = targetPart.Position
                local targetVelocity = targetPart.Velocity
                
                local leadshotPosition = CalculateLeadshot(targetPosition, targetVelocity, projectileSpeed)
                
                for _, bullet in ipairs(workspace:GetDescendants()) do
                    if bullet:IsA("Part") and bullet.Name == "Bullet" then
                        if not bullet:GetAttribute("CreationTime") then
                            bullet:SetAttribute("CreationTime", tick())
                        end
                        
                        SmoothAdjustBulletTrajectory(bullet, leadshotPosition)
                        ApplyBulletDrop(bullet, projectileSpeed, gravity.Y)
                    end
                end
            end
        end
    end
end)

-- Th√™m m·ªôt h·ªá th·ªëng ph√°t hi·ªán anti-cheat ƒë∆°n gi·∫£n
local function DetectAntiCheat()
    for _, v in ipairs(game:GetDescendants()) do
        if v:IsA("LocalScript") and v.Name:lower():match("anticheat") then
            warn("Possible anti-cheat detected: " .. v:GetFullName())
        end
    end
end

DetectAntiCheat()

-- Th√™m t√≠nh nƒÉng t·ª± ƒë·ªông n√© ƒë·∫°n
local function AutoDodge()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    for _, bullet in ipairs(workspace:GetDescendants()) do
        if bullet:IsA("Part") and bullet.Name == "Bullet" and not bullet:IsDescendantOf(character) then
            local distance = (bullet.Position - character.HumanoidRootPart.Position).Magnitude
            if distance < 10 then
                local dodgeDirection = (character.HumanoidRootPart.Position - bullet.Position).Unit
                humanoid:Move(dodgeDirection * 10)
            end
        end
    end
end

RunService.Heartbeat:Connect(AutoDodge)
----------------------------------------------------------------------------
local DinhvidoToggle = MainSection:AddToggle("badoToggle", {
    Title = "ƒê·ªãnh v·ªã 360",
    Default = Configuration.bado
})

local TeamCheckToggle = MainSection:AddToggle("teamCheckToggle", {
    Title = "Team Check",
    Default = false
})

local SizeSlider = MainSection:AddSlider("sizeSlider", {
    Title = "K√≠ch th∆∞·ªõc ch·ªâ b√°o",
    Default = 40,
    Min = 20,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        -- C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc cho t·∫•t c·∫£ c√°c ch·ªâ b√°o hi·ªán c√≥
        for _, indicator in pairs(indicators) do
            indicator.Size = UDim2.new(0, Value, 0, Value)
        end
    end
})

local updateConnection
local indicators = {}
local teamCheck = false
local indicatorSize = 40

DinhvidoToggle:OnChanged(function(Value)
    Configuration.do360ESPEnabled = Value
    if Value then
        -- T·∫°o ScreenGui n·∫øu ch∆∞a t·ªìn t·∫°i
        if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("ESP360Gui") then
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.Name = "ESP360Gui"
            ScreenGui.ResetOnSpawn = false
            ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            ScreenGui.Parent = game.Players.LocalPlayer.PlayerGui
        end

        local function createIndicator()
            local indicator = Instance.new("ImageLabel")
            indicator.Size = UDim2.new(0, indicatorSize, 0, indicatorSize)
            indicator.BackgroundTransparency = 1
            indicator.Image = "rbxassetid://18341831594"
            indicator.ImageColor3 = Color3.new(1, 1, 1)
            indicator.ImageTransparency = 0
            
            indicator.Parent = game.Players.LocalPlayer.PlayerGui.ESP360Gui
            return indicator
        end

        local function updateIndicators()
            for _, player in ipairs(game.Players:GetPlayers()) do
                if player ~= game.Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    -- Ki·ªÉm tra Team Check
                    if teamCheck and player.Team == game.Players.LocalPlayer.Team then
                        if indicators[player] then
                            indicators[player].Visible = false
                        end
                        continue
                    end

                    local indicator = indicators[player]
                    if not indicator then
                        indicator = createIndicator()
                        indicators[player] = indicator
                    end
                    
                    local playerPos = player.Character.HumanoidRootPart.Position
                    local cameraPos = workspace.CurrentCamera.CFrame.Position
                    local cameraLookVector = workspace.CurrentCamera.CFrame.LookVector
                    
                    local relativePos = (playerPos - cameraPos).Unit
                    local dotProduct = cameraLookVector:Dot(relativePos)
                    local angle = math.acos(dotProduct)
                    
                    local cross = cameraLookVector:Cross(relativePos)
                    if cross.Y < 0 then
                        angle = -angle
                    end
                    
                    local screenSize = workspace.CurrentCamera.ViewportSize
                    local radius = math.min(screenSize.X, screenSize.Y) * 0.45
                    local centerX, centerY = screenSize.X / 2, screenSize.Y / 2
                    
                    local adjustedAngle = angle + math.pi/2
                    
                    local x = centerX + radius * math.cos(adjustedAngle)
                    local y = centerY - radius * math.sin(adjustedAngle)
                    
                    indicator.Position = UDim2.new(0, x - indicator.AbsoluteSize.X/2, 0, y - indicator.AbsoluteSize.Y/2)
                    indicator.Rotation = math.deg(angle)

                    local _, onScreen = workspace.CurrentCamera:WorldToScreenPoint(playerPos)
                    
                    indicator.Visible = not onScreen
                else
                    if indicators[player] then
                        indicators[player].Visible = false
                    end
                end
            end
        end

        updateConnection = game:GetService("RunService").RenderStepped:Connect(updateIndicators)

        game.Players.PlayerRemoving:Connect(function(player)
            if indicators[player] then
                indicators[player]:Destroy()
                indicators[player] = nil
            end
        end)

    else
        -- T·∫Øt ESP 360
        if updateConnection then
            updateConnection:Disconnect()
        end
        for _, indicator in pairs(indicators) do
            if indicator then
                indicator:Destroy()
            end
        end
        indicators = {}
        if game.Players.LocalPlayer.PlayerGui:FindFirstChild("ESP360Gui") then
            game.Players.LocalPlayer.PlayerGui.ESP360Gui:Destroy()
        end
    end
end)

TeamCheckToggle:OnChanged(function(Value)
    teamCheck = Value
end)

SizeSlider:OnChanged(function(Value)
    indicatorSize = Value
    for _, indicator in pairs(indicators) do
        indicator.Size = UDim2.new(0, Value, 0, Value)
    end
end)
---------------------------------------------------------------------------- 
-- Ph·∫ßn code hi·ªán t·∫°i c·ªßa b·∫°n

-- Th√™m v√†o cu·ªëi file
local UIVisible = true

local function ToggleUI()
    UIVisible = not UIVisible
    Window.Enabled = UIVisible
end

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.F1 then
        ToggleUI()
    end
end)

